#什么是指针

>引言： 在C语言中，内存地址对于程序员来说是可操作的。用于表示内存地址的数据项，就称为指针。

---

##相关概念

######内存地址
* 现代计算机爸内存分割成**字节**，每个字节可以存储8位。
* 每个字节都有一个唯一的编号，这个编号称为**内存地址**。
* 一个内存地址只占**4个
* 字节**,是一个**整数值**。
* 程序中每个变量占用内存中的一个或多个字节，把其占用的第一个字节的地址称为变量的**地址**。
* **直接引用：**使用变量名引用变量的方法。<br>**简介引用：** 知道某个数据的数据类型，然后通过它的内存地址进行引用的方法。

######指针变量的声明
当"*"以这种形式出现在变量定义中，它表示在被定义的变量是一个指针。**指针可以被定义为指向任何数据类型的对象**。

```c
int *i;   //声明i是一个指向整型数据的指针(没有赋值初始化)。
```

######指针变量的初始化
**指针变量在使用时，必须赋初值**。指针变量可以被初始化NULL(<stdio.h>中定义的符号常量)、0或一个地址。值为NULL的指针表示它不指向任何对象。将指针初始化为0等价于初始化为NULL(但初始化为NULL更好，因为用0为指针赋值时，它需要被转化为相应类型的指针).

######指针和数据类型
例如，如下语句：
```c
int count = 1000, *cntptr;
cntptr = &count;/* 指针变量cntptr包含的信息是，count的地址和它的数据类型为int。*/
```
所以，每个指针都和某个数据类型相关联。如果某一个指针变量被声明int类型(或其，那么该指针变量就只能指向整型变量，而不能指向其他类型的变量。**仅在类型相同时，一个指针才能赋值给另一个指针**。

**void类型的指针**，它是可以表示任何类型的通用指针——void类型的指针可以和其他任何类型的指针相互赋值，都无需使用类型转换运算符。但是，指向void类型的指针，不能进行间接寻址运算，因为void类型的指针只是简单地包含一个未知数据类型的首地址，这个指针一次读取的字节数对编译器而言是未知的。

######指针的基本运算
&：取地址运算符。以左值为操作数，返回操作数所在的内存地址。

\*：取指针所指内存对象的数据。"*"通常被称为间接寻址运算符(indirection operator),它返回其操作数(即一个指针)指向对象的值。例如，语句：
```C
int count = 1000, *cntptr;
cntptr = &count; //将变量count的地址赋值给指针变量cntptr
printf("%d\n",*cntptr); //等价于printf("%d\n",count)
/* count和*cntptr具有等价关系，也可以说*cntptr是对count的引用 */
```

##指针作为函数的参数
>向函数传递实参的方法有两种：**按值传递和按引用传递**。C语言中，所有实参都是按值传递的，在发生函数调用时，系统为被掉
·函数的形参分配新的内存，将实参的值复制到对应的形参变量中。形参只是实参的副本，在被掉函数函数中访问这个参数，只是访问实参的副本，对调用函数中的实参没有任何影响。C语言的这种按值传递的机制，符合“最小权限原则”，即减小被掉函数的权限，避免**被掉函数**修改**主调函数**中的变量。

当函数需要把多个值返回主调函数时，用return语句返回就不合适了。解决这个问题的办法就是写成一个不需要返回值的过程，通常指针作函数参数的方法实现，具体实现：

1. 在主调函数中，将该变量的地址作为实参；
2. 在被掉函数中，定义一个指针类型的形参来接收这个地址；
3. 在被掉函数中，用形参指针间接访问主调函数中的变量。 



