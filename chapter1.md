#什么是指针

>引言： 在C语言中，内存地址对于程序员来说是可操作的。用于表示内存地址的数据项，就称为指针。

---

##相关概念

######内存地址
* 现代计算机爸内存分割成**字节**，每个字节可以存储8位。
* 每个字节都有一个唯一的编号，这个编号称为**内存地址**。
* 一个内存地址只占**4个
* 字节**,是一个**整数值**。
* 程序中每个变量占用内存中的一个或多个字节，把其占用的第一个字节的地址称为变量的**地址**。
* **直接引用：**使用变量名引用变量的方法。<br>**简介引用：** 知道某个数据的数据类型，然后通过它的内存地址进行引用的方法。

######指针变量的声明
当"*"以这种形式出现在变量定义中，它表示在被定义的变量是一个指针。**指针可以被定义为指向任何数据类型的对象**。

```c
int *i;   //声明i是一个指向整型数据的指针(没有赋值初始化)。
```

######指针变量的初始化
**指针变量在使用时，必须赋初值**。指针变量可以被初始化NULL(<stdio.h>中定义的符号常量)、0或一个地址。值为NULL的指针表示它不指向任何对象。将指针初始化为0等价于初始化为NULL(但初始化为NULL更好，因为用0为指针赋值时，它需要被转化为相应类型的指针).

######指针和数据类型
例如，如下语句：
```c
int count = 1000, *cntptr;
cntptr = &count;/* 指针变量cntptr包含的信息是，count的地址和它的数据类型为int。*/
```
所以，每个指针都和某个数据类型相关联。如果某一个指针变量被声明int类型(或其，那么该指针变量就只能指向整型变量，而不能指向其他类型的变量。**仅在类型相同时，一个指针才能赋值给另一个指针**。

**void类型的指针**，它是可以表示任何类型的通用指针——void类型的指针可以和其他任何类型的指针相互赋值，都无需使用类型转换运算符。但是，指向void类型的指针，不能进行间接寻址运算，因为void类型的指针只是简单地包含一个未知数据类型的首地址，这个指针一次读取的字节数对编译器而言是未知的。

######指针的基本运算
&：取地址运算符。以左值为操作数，返回操作数所在的内存地址。

\*：取指针所指内存对象的数据。"*"通常被称为间接寻址运算符(indirection operator),它返回其操作数(即一个指针)指向对象的值。例如，语句：
```C
int count = 1000, *cntptr;
cntptr = &count; //将变量count的地址赋值给指针变量cntptr
printf("%d\n",*cntptr); //等价于printf("%d\n",count)
/* count和*cntptr具有等价关系，也可以说*cntptr是对count的引用 */
```

##指针作为函数的参数
>向函数传递实参的方法有两种：**按值传递和按引用传递**。C语言中，所有实参都是按值传递的，在发生函数调用时，系统为被掉
·函数的形参分配新的内存，将实参的值复制到对应的形参变量中。形参只是实参的副本，在被掉函数函数中访问这个参数，只是访问实参的副本，对调用函数中的实参没有任何影响。C语言的这种按值传递的机制，符合“最小权限原则”，即减小被掉函数的权限，避免**被掉函数**修改**主调函数**中的变量。

当函数需要把多个值返回主调函数时，用return语句返回就不合适了。解决这个问题的办法就是写成一个不需要返回值的过程，通常指针作函数参数的方法实现，具体实现：

1. 在主调函数中，将该变量的地址作为实参；
2. 在被掉函数中，定义一个指针类型的形参来接收这个地址；
3. 在被掉函数中，用形参指针间接访问主调函数中的变量。 

##指针与const限定符
>const限定符的作用是告诉编译器这个被const限定的变量的值是不可改写的。可以使用const限定符实现“最小权限原则”。如果有语句试图改写一个声明为const的变量的值，那么编译器会检测出这个错误并发出警告或错误提示。

######1.指向可变数据的可变指针
**程序：将一个字符串中所有小写字母转换为大写字母。**
```C
#include<stdio.h>
#include<ctype.h>
void ConvertToUpper(char *sptr);

int main (void)
{
    char str[100];
    gets(str);
    ConvertToUpper(str);
    puts(char);
    return 0;
}

/* 把字符串全转化为大写 */
void ConvertToUpper(char *sptr)
{
    for(; *sptr != '\0'; sptr++)
        *sptr = toupper(*sptr);z 
}
```
ConvertToUpper()函数的形参指针sptr是指向可变数据的可变指针，拥有最高数据访问权限。函数不仅可以通过间接访问改写sptr所指向的存储单元中的数据，还可以改写sptr的值，使其指向其他的数据项。

######2.指向常量数据的可变指针
这种情况下，形参可以改变指向，但不能改变其所指向的存储单元的数据。

**程序：输出字符串，形参声明为指向常量数据的指针变量**。
```C
void PrintStr(const char *sptr)
{
    for(; *sptr != '\0'; *sptr++)
        putchar(*sptr);
}
```
其中，形参的定义形式为：
```C
const char *sptr
```
这个声明**从右向左**念做“**sptr是一个指针，指向字符常量**”。如果试图改变sptr所指内存单元的内容，则出现编译错误。

######3.指向可变数据的指针常量
一个指向可变数据的指针常量，指向总是不变的，而存储在指向的内存单里的数据可以通过指针来改写。**数组名就是这种指针常量，总是指向数组的起始位置。而数组的所有元素都可以通过数组名加下标来访问和改写。**

**声明为const的指针，必须在定义的同时初始化，如果指针是函数的参数，那么它由传递给函数的实参来初始化。**

**程序：试图修改指针常量的指向。**
```C
#include<stdio.h>

int main (void)
{
    int x, y;
    /* 声明ptr是一个指向可变数据的指针常量 */
    int * const ptr =&x; //这个定义从右向左读：ptr是指针常量，指向一个整型数据。

    *ptr = 5; /*合法*/
    ptr = &y; /*不合法，ptr只一个指针常量，不能改变指向*/
    return 0;
}
```

######4.指向常量数据的指针常量





